---
layout: default
title: InnoDB索引
published: 2019-10-05
tags: [数据库]
---
**概述**
- InnoDB会有聚簇索引，默认是主键构建，如果没有主键，则找第一个唯一非空索引，找不到就创建一个6字节的隐式主键。
- 聚簇索引中的顺序就是数据存放的顺序，所以一个表只能有一个聚簇索引
- 数据库读取数据的时候是以页位单位的，所以有时候插入删除会导致页分裂之类的现象，而聚簇索引的顺序就是存储顺序，所以对聚簇索引的增加删除很有可能导致页分裂
- 辅助索引的叶子节点的记录存储的是聚簇索引列号（相当于间接查询该条记录的聚簇索引列值）

**B-TREE索引的特点**
1. 有效
    - 全值匹配
    - 匹配最左前缀
    - 匹配列前缀
    - 匹配范围值
    - 精确匹配某一列并范围匹配另一列
    - 只访问索引的查询
2. 限制
    - 如果不是按照最左列开始查询，则无法使用（优化器会优化的）
    - 不能跳过索引中的列
    - 如果查询中有某个列的范围查询，则右侧的都无法使用索引  

**哈希索引特点**
- 只有精确匹配索引所有的列的查询才有效
- 只包含哈希值和行指针，所以不能使用索引中的值来避免读行（影响不大）
- 并不是按照索引值顺序进行排序，所以也就无法用于排序
- 不支持部分索引列匹配查找
- 只支持等值比较（=、IN()、<=>），也不支持任何范围查询
- 访问数据非常快，除非哈希冲突很多（拉链法）
- 哈希冲突很多的时候，维护索引代价就很大
- InnoDB有自适应哈希索引  

**覆盖索引**
- InnoDB支持覆盖索引（或索引覆盖）
- 索引中如果包含全部的查询信息，就不需要去聚簇索引再查询
- 对于统计查询（count），如果条件在覆盖索引中，那么可以跳过列使用联合索引，如，联合索引（a,b），正常情况下只查询b是不走联合索引的，但是如果是select count(*) from table where b...... 这个是可以走的  

**索引提示**
```sql
SELECT * FROM  table_name USE INDEX(index_name) WHERE ......
```

**全文检索**
- 当like是前缀匹配的时候是可以走B-Tree索引的，否则就不走了
- InnoDB1.2.x开始支持全文检索
- 倒排索引两种形式：  InnoDB采用的是full inverted index
    1. inverted file index：{单词，单词所在文档的id}
    2. full inverted index：{单词，（单词所在文档的id，在具体文档中的位置}
- 倒排索引需要将word存到一张Auxiliary Table中（辅助表），在InnoDB中，为提高全文检索的并行性，有6张辅助表
- FTS Index Cache全文检索索引缓存用来提高全文检索的性能
- InnoDB全文检索的限制条件  
    1. 每张表只能有一个全文检索的索引
    2. 多列组合而成的全文索引必须使用相同的字符集与排序规则
    3. 不支持没有单词界定符的语言，如中文、日语、韩语等  

```sql
创建全文索引：
建表时：FULLTEXT KEY 'index_name' (col1,col2)
更新表：UPDATE TABLE table_name ADD FULLTEXT INDEX index_name(col1,col2)
索引类型可以为 UNIQUE/FULLTEXT/SPATIAL/不写
```

**ORDER BY 是否走索引**
- 只有当索引的列顺序和order by子句的顺序完全一致，且所有列的排序放向（正序或逆序）一致时，才可以走索引（order by的顺序是有权重的，不可以优化）
- 如果前边的列指定一个定值，则可以跳过，继续order by，如果前边的列是范围查询，那就不行了  