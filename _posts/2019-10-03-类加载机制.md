---
layout: default
title: 类加载机制
tags: [深入理解JVM虚拟机,java]
published: 2019-10-03
---
**5种情况必须对类进行初始化**

 1. 遇到new、getstatic、pubstatic、invokestatic这四种字节码指令，如果类没有初始化，则立即初始化，最常见的场景是new实例化对象，设置或读取一个类的静态字段（被final修饰，在编译阶段就进入常量池的静态常量除外）
 2. 反射调用
 3. 初始化一个类的时候，如果父类没有初始化，则初始化父类
 4. 虚拟机启动的时候，初始化主类
 5. JDK1.7动态语言支持时，如果一个java.lang.invoke.MethodHandle实例最后解析的结果为REF_getStatic、REF_putStatic、REF_invokeStatic的方法句柄，并且该句柄对应的类没有进行过初始化，则初始化该类
<u>有且只有这五种情况称为对一个类进行主动引用</u>

**加载**

 1. 通过一个类的全限定名获取此类的二进制字节流
 2. 将该字节流对应的静态存储结构转化为方法区的运行时数据结构
 3. 在内存种生成一个java.lang.Class对象，作为方法区这个类的各种数据的访问接口

**验证**

 1. 文件格式验证：魔数开头、主次版本号是否在虚拟机处理范围内等
 2. 元数据验证：是否有父类、是否继承了不该继承的类（final）、是否实现了抽象父类中的方法等
 3. 字节码验证：确定程序语义合法、符合逻辑
 4. 符号引用验证：发生在将符号引用转化为直接引用的时候

**准备**

 - 正式为类分配内存并设置初始值
 - 处理的是类变量，不是实例变量
 - 初始值一般指的是零值，常量值的话会赋指定值

**解析**

 - 发生在将符号引用替换为直接引用的过程中
 - 符号引用：引用目标不一定已经加载到内存中
 - 直接引用：指向目标在内存中的地址、偏移量、句柄等，必定是已经加载到内存中的

**初始化**

 - 真正开始执行Java代码

**类加载器**

 - 启动类加载器（boostrap），加载JAVA_HOME/lib中的，或者-Xbootclasspath指定的
 - 扩展类加载器（extension），加载JAVA_HOME/lib/ext中的
 - 应用程序加载类（application），加载用户路径中的

**为什么要破坏双亲委派模型？**  
有时候JDK只提供了接口，没有提供实现，具体实现由厂商自己做，但是Boostrap类加载器只能加载lib下的类，所以就需要父类加载器调用子类加载器去加载具体实现类。

**如何打破双亲委派模型**  
重写loadClass方法