---
layout: default
title: HotSpot垃圾回收器与内存分配策略
tags: [深入理解JVM虚拟机,java]
published: 2019-10-03
---
@[toc]
### 对象已死吗？
#### 引用计数算法
存在循环引用问题
#### 可达性分析算法

 - **GC Roots**对象作为起始点
 - 走过的路径称为**引用链**

**可作为GC Roots的对象**
1. 虚拟机栈中引用的对象
2. 方法区中类静态属性引用的对象
3. 方法区中常量引用的对象
4. 本地方法栈中JNI引用的对象

#### 生存还是死亡

 1. 可达性分析后判定不可达后判断是否有必要执行finalize（）方法
 2. 对象没有覆盖finalize方法或者已经执行过该方法，就挂了
 3. 如果有必要执行，放入F-Queue队列
 4. 稍后一个虚拟机建立的，优先级低的Finalizer线程将执行它们的finalize方法，但不保证会等待执行结束
 5. 在这个过程中加入了引用链，则在第二次标记的时候会被移除“回收列表”
 6. 所以有两次标记
 7. 注意，一个对象的finalize方法只能执行一次，躲过一次回收，下一次就不行了

#### 再谈引用

 - 强引用：程序代码中普遍存在的，垃圾回收器永远不会回收存在强引用的对象
 - 软引用：描述还有用但并非必需的对象，在系统将要发生内存溢出时将会对这些对象进行回收。通过SoftReference类实现软引用
 - 弱引用：强度比软引用更弱一些，垃圾回收器工作时，无论内存是否足够，都会回收这些对象。WeakReference类实现
 - 虚引用：也称幽灵引用或者幻影引用，最弱的引用，一个对象是否有虚引用不会对其生存时间构成影响，也无法通过虚引用来获得一个对象实例。唯一目的是在该对象被回收时可以得到一个通知。通过PhantomReference类来实现

### 垃圾回收算法
##### 标记-清除算法

 - 标记和清除两个过程效率都不高
 - 标记清除之后的空间不连续，会导致之后无法分配内存给较大的对象，从而导致gc

##### 复制算法

 - 实现简单，效率高
 - 在对象存活率较高的时候需要多次复制，效率下降
 - 如果不想浪费50%的空间，就需要额外的空间担保

##### 标记整理算法

 - 标记过程与标记-清除算法一样
 - 后续过程不再是清除，而是让所有活动的对象移动到一端
 - 最后直接清除端边界以外的内存

##### 分代收集算法
### HotSpot的算法实现
##### 枚举根节点

 - 逐个检查引用很耗费时间
 - 分析工作必须在一个能保证**一致性**的快照中进行，所有有STW，即使在号称几乎不会发生停顿的CMS收集器中，枚举根节点时也必须要停顿
 - OopMap的数据结构可以让虚拟机快速知道哪些地方有引用（类加载时把对象内什么偏移量上什么数据计算出来），在停顿的时候可以完成快速枚举
##### 安全点
 - 引用关系可能经常变换，维护OopMap代价也很大，所以并非每次指令都有OopMap，只有特定的安全点才有（快照？）
 - 所以程序执行时并非在任何地方都能停下来GC，要走到安全点，所有线程都要到自己的安全点

**如何保证所有线程都处于安全点后开始GC**

 - 抢先式中断：中断所有线程，发现有的线程没有到安全点，让它继续执行
 - 主动式中断：需要GC时，设置一个标识，各线程轮询这个标识，如果为真就挂起

##### 安全区域
**有的线程没有得到CPU时间，无法走到安全点，比如sleep和blocked状态，此时需要安全区**
*安全区：在一段代码片段中，引用关系不会发生变化，在这个区域中任何一个地方GC都是安全的*

### 垃圾收集器
#### Serial	

 - 单线程
 - 工作时暂停其余线程
 - Serial Old
 - 依然是运行在Client模式下的新生代默认收集器

#### ParNew

 - Serial的多线程版本
 - 除Serial外目前只有它能与CMS（老年代收集器）配合工作
 - **在单CPU环境中，ParNew一定不会比Serial好**

#### Parallel Scavenge

 - 新生代并行多线程收集器，采用复制算法
 - 其余的收集器关注停顿时间，而Parallel Scavenge关注吞吐量（运行用户代码时间/（运行代码时间+垃圾回收时间））
 - GC自适应的调节策略

#### Serial Old

 - Serial收集器老年代版本
 - 单线程，标记-整理算法
 - 一般也用于Client模式下
 - 如果是Server模式，那还有两大用途：1.在1.5及之前的版本与ParallelScavenge配合使用；2.作为CMS的预备方案，并在发生Cocurrent Mode Failure时使用

#### Parallel Old

 - Parallel Scavenge收集器的老年代版本
 - 多线程，标记-整理

#### CMS

 - concurrent mark sweep，显然基于标记-清除
 - 四个步骤：1.初始标记；2.并发标记；3.重新标记； 4.并发清除
 - 初始标记、重新标记两个阶段仍然需要STW
 - 初始标记仅仅标记一下GC Roots能关联到的对象，速度很快
 - 并发标记是进行GC Roots Tracing的过程
 - 重新标记是修正并发标记期间用户程序继续进行而导致的变动
 - 整个过程耗时最多的并发标记和并发清除都可以与用户线程一起工作

**缺点**

1. 对CPU资源非常敏感，默认开启的回收线程数（cpu数量+3）/4;
2. 无法处理浮动垃圾，可能出现concurrent mode failure从而导致另一次full gc（下文介绍）
3. 标记清除会有碎片  

<u>并发清除阶段用户程序会产生新的垃圾，只能下次再清除，这些就是**浮动垃圾**，也因为用户程序依然再运行，所以要预留足够的内存给用户线程使用，并不能像其它收集器一样在老年代几乎被填满了的时候才进行收集，如果在CMS运行阶段预留内存无法满足程序的需要，就会引发concurrent mode failure，此时将启动serial old来重新进行老年代收集，这样停顿时间就长了</u>

### g1垃圾回收器
- 并行与并发：充分利用多CPU、多核环境优势，并发方式解决停顿
 - 分代收集：可以独立管理整个GC堆
 - 空间整合：从整体上看基于标记-整理，从局部上看基于复制，总之不会有碎片
 - 可预测的停顿：可以指定在M的时间片内，消耗在垃圾收集上的时间不能超过N（所以还是有停顿），这几乎是 **RTSJ(Java实时垃圾回收器)**的特征了

### 垃圾回收器参数总结
### 内存分配与回收策略
#### 对象优先在Eden分配

 - 当Eden没有足够空间的时候，虚拟机将发起一次minor gc
 - 不是所有的full gc都伴随minor gc，在parallel scavenge收集器的收集策略里有直接进行major gc的

#### 大对象直接进入老年代
#### 长期存活的对象进入老年代
#### 动态对象年龄判定

 - 并不是非得到年龄才进入老年代
 - 如果survivor中相同年龄的一批对象总和大于survivor一半空间，则大于等于该年龄的对象可进入老年代

#### 空间分配担保

 - minor gc前，虚拟机会检查老年代最大可用连续空间是否大于新生代所有对象总空间，如果成立，则minor gc是安全的
 - 如果不成立，虚拟机会查看是否允许担保失败HandlePromotionFailure
 - 如果允许担保失败，则检查老年代最大连续可用空间是否大于历次晋升到老年代的对象的平均大小，如果大于，则尝试进行minor gc
 - 如果小于，或者不允许担保失败，则进行full gc