---
title: JVM运行时的数据区域
layout: default
published: 2019-10-02
tags: [深入理解JVM虚拟机,java]
---

### 运行时的数据区域

 - 程序计数器
 - Java虚拟机栈
 - 本地方法栈
 - Java堆
 - 方法区
 - 运行时常量池
 - 直接内存

**程序计数器**

 - 线程私有
 - 如果是Java方法，记录的是当前执行的虚拟机字节码地址
 - 如果是native方法，undefined
 - 是虚拟机规范中唯一没有规定任何OOM情况的区域
 
 **Java虚拟机栈**
 
 - 线程私有，与线程同声明周期
 - 栈帧有：局部变量表、操作数栈、动态链接、方法出口等
 - 两种异常情况：1.超过允许的最大深度：Stack'OverflowError；2. 如果可以动态扩展，在扩展时无法申请到内存，则OOM

**本地方法栈**

 - native方法
 - 也有StackOverflowError和OOM

**Java堆**

 - 所有线程共享，在虚拟机启动时创建
 - 规范中描述：所有对象实例以及数组都要在堆上创建，但==JIT编译器的发展与逃逸分析技术==愈发成熟，此条不绝对
 - 逻辑上连续，物理上不必须连续
 - 有OOM

**方法区**

 - 线程共享
 - 用于存储被虚拟机加载过的<u>**类信息、常量、静态变量、即时编译器编译后的代码等数据**</u>
 - 别名Non-Heap，可能是要与Java堆区别开
 - 并不等同于永久代，hotspot中才有永久代概念，别的虚拟机不一定有（IBM J9、BEA JRockit等）
 - 可以选择不回收垃圾
 - 有OOM

**运行时常量池**

 - 方法区的一部分
 - 存放编译器生成的各种字面量和符号引用
 - 运行时也可以放入，比如String的intern（）方法
 - OOM

**直接内存**

 - Java1.4中有了NIO，可以使用native方法申请堆外内存，然后通过存储在Java堆中的DirectByteBuffer对象作为引用进行操作
 - 依然受到机器内存的限制，所以会OOM