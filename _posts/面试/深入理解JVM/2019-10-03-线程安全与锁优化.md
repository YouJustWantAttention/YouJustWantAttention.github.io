---
layout: default
title: 线程安全与锁优化
published: 2019-10-03
tags: [深入理解JVM虚拟机,java]
---
*线程安全：当多个线程访问一个对象时，如果不用考虑这些线程在运行时环境下的调度和交替执行，也不用额外的同步或者调度方法进行任何其它的协调操作，调用这个对象都能获得正确的结果，那这个对象是线程安全的*  

**Java中安全程度由强到弱的5类共享数据**
1. 不可变：不可变对象是绝对安全的
2. 绝对线程安全：基本不存在，Vector中，如果一个线程删除了一个元素导致i序号不可以，另一个线程在访问的时候就有越界异常（vector的size变了）
3. 相对线程安全：Java中大部分线程安全类都是这种类型
4. 线程兼容：当我们说一个类不是线程的，大部分时候就是这这个类型的类，如HashMap等
5. 线程对立：无论怎样采用同步措施，都不能保证线程安全，一个例子是Thread类的suspend和resume方法，如果两个线程同时持有一个线程对象，并发执行这两个操作，无论怎样都可能死锁  

**线程安全的实现方法**  
1. 互斥同步：悲观锁，Java已经优化了很多不必要加锁的情况
2. 非阻塞同步：乐观锁，先操作，如果没有竞争，那就操作成功，如果有竞争，操作失败后再补救，一般是不断尝试。需要硬件支持，操作和冲突检测需要原子性。CAS三个操作数：内存位置，预期值，新值
3. 无同步方案：如果一段代码本身就不涉及共享数据，那自然无需任何同步措施    

 **锁优化**  
 - 自旋锁与自适应自旋：本来自旋默认10次，1.6后的自适应自旋会根据情况自己判断
 - 锁消除：编译器对检测到的不可能存在共享数据竞争的锁进行消除，判断依据来源于**逃逸分析**的数据支持
 - 锁粗化：原则上我们在写代码的时候会尽量将锁的范围缩小，但是有的时候频繁的没有必要的加锁解锁会损耗性能（如在循环体中加锁），这种时候就会粗化
 - 轻量级锁：  
    1. 如果同步对象没有被锁定（01），虚拟机在当前线程的栈帧中建立一个名为所记录的空间，存储锁对象目前的mark word的拷贝，然后CAS尝试将对象的mark word存储为指向锁记录的指针，如果成功了，那就获取了锁，而对象的mark word 也成为指向栈帧中锁记录的指针，其状态位也改成00  
    2. 如果失败了，查看是否是自己持有锁，如果是就继续执行，如果不是，那锁膨胀为重量级锁
    3. 提升性能的依据是，对于绝大部分锁，在整个同步周期内都是不存在竞争的  
- 偏向锁：偏向第一个获取它的线程

|存储内容|标志位|状态|  
|--|--|--|
|对象的哈希码，对象的分代年龄|01|未锁定|  
|指向锁记录的指针|00|轻量级锁|  
|指向重量级锁的指针|10|膨胀（重量级锁）|  
|空，不需要记录|11|GC标记|  
|偏向线程id、偏向时间戳、对象分代年龄|01|可偏向|  


