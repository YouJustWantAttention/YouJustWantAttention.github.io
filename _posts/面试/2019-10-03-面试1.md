---
layout: default
title: 面试1
published: 2019-10-03
tags: [面试]
---
**浏览器输入URL，点击后的事情**  
1. url解析
    - 判断是地址，还是搜索关键字
2. DNS解析
    1. 浏览器缓存
    2. OS缓存
    3. 路由器缓存
    4. ISP DNS缓存（首选的DNS服务器缓存）
    5. 根域名服务器查询
    -  *DNS劫持*：域名劫持是互联网攻击的一种方式，通过攻击域名解析服务器（DNS），或伪造域名解析服务器（DNS）的方法，把目标网站域名解析到错误的地址从而实现用户无法访问目标网站的目的。
3. TCP连接
    - *SYN泛洪攻击*：SYN攻击利用的是TCP的三次握手机制，攻击端利用伪造的IP地址向被攻击端发出请求，而被攻击端发出的响应 报文将永远发送不到目的地，那么被攻击端在等待关闭这个连接的过程中消耗了资源，如果有成千上万的这种连接，主机资源将被耗尽，从而达到攻击的目的。
4. 处理请求
5. 接受响应
6. 渲染页面  

**TCP与UDP的区别**
1. TCP面向连接、UDP无连接
2. TCP提供可靠服务，传送的数据无差错、不丢失，不重复，且按序到达；UDP尽最大努力交付，不保证可靠交付
3. TCP面向字节流；UDP面向报文，UDP没有拥塞控制，网络出现拥塞不会使源主机的发送速率降低
4. TCP只能点到点；UDP可以一对一、一对多、多对一、多对多
5. TCP首部开销20字节，UDP首部开销8字节
6. TCP的全双工可靠信道，UDP不可靠
7. TCP可靠但是速度慢，若数据的可靠性、完整性优先，用TCP，如文件传输等
8. UDP不可靠但是速度快，若数据的实时性优先，用UDP，如视频传输、实时通信等  

**如何实现可靠UDP**  
UDP可靠性需要上层应用实现，一般采用**消息重传**来保证可靠  
1. 发送者发起：接收者发送确认，发送者维护一个计时器，一定时间后没有确认的就重复。因为要确认每一个发送的消息，容易引起发送者溢出--发送者内爆（ACK内爆）
2. 接收者发起：接收者负责错误检测，发现丢包时发送重传信息。如果一个包没有到达任何一个接收者，那么发送者会接收到很多重传消息，导致负载过高和过多的重传，称为NACK内爆，可以使用定时器来限制消息包的重传。这种方式用的比较多  

**TCP11种状态**  
1. closed：初始状态
2. listen：服务器某个socket处于监听状态
3. syn_sent：客户端已发送SYN报文
4. syn_rcvd：接收到SYN报文
5. established：连接建立
6. fin_wait_1:等待接收对方的fin报文，主动关闭时发送，接收ACK报文后进入fin_wait_2
7. fin_wait_2:
8. time_wait:接收到了对方的FIN报文，并且发送了ACK报文，等2MSL后进入closed。如果在fin_wait_1的状态接收到了对方的带fin标识和ack的报文时，无需进入time_wait_2阶段，直接进入time_wait
9. closing：发送fin报文后，并没有收到ACK报文，反而收到了FIN报文（双方同时关闭），此时就进入closing
10. close_wait：等待关闭。传输剩余数据
11. last_ack：等待最后的ACK报文  

**2MSL的作用**
- MSL=maximum segment lifetime
- 当last_ack没有被接收到的时候，对方会重发FIN报文，此状态用来接收这个FIN并重发ACK，否则客户端将响应RST，导致服务端异常（connection reset的SocketException）
- 保证此次连接的报文都失效，避免新旧连接混淆

**TCP重发机制**  
- 超时重传和快速重传同时使用，互补
- 超时重传一直重发到次数上限或者收到ACK
- 快速重传：连续3次收到一个序列的ACK
- 为什么要重发？  
    1. 物理层无法做到可靠，只能依靠协议  

**TCP连接建立后，每个TCP数据包都要被确认，简单讲TCP通过确认/重传机制实现数据的可靠传输**

**Nagle算法**  
- 用来避免发送小的数据包，要求TCP连接上最多只能有一个为被确认的小分组，该分组被确认前不能发送其它的分组
- 规则：  
    1. 如果包长度达到MSS，允许发送
    2. 该包有FIN，允许发送
    3. 设置了TCP_NODELAY选项，允许发送；
    4. 未设置TCP_CORK时，若所有小分组都被确认，允许发送
    5. 上述条件都未满足，但是发生了超时，立即发送  

**TCP的拥塞控制**
- 慢开始
    - cwnd发送窗口一开始设置为1，每次收到一个确认，就*2
    - 这个慢指的是一开始的起点低，不是速度慢
- 拥塞避免
    - ssthresh慢开始门限
    - cwnd < ssthresh 时使用慢开始
    - cwnd > ssthresh 时改用拥塞避免
    - 线性增长，每次+1
    - 发生超时时，ssthresh = cwnd/2， 同时设置cwnd = 1（未使用快恢复）
- 快重传
    - 连续收到3个重复确认时，立刻对该报文进行重传
- 快恢复
    - 拥塞之后，ssthresh = cwnd/2，cwnd = ssthresh，然后开始执行拥塞避免算法  

<u>接收窗口rwnd和拥塞窗口cwnd共同制约着发送窗口，发送窗口上限=Min（rwnd，cwnd）</u>  
 
 **ARP**  
 *地址解析协议，用来解决同一个局域网上的主机或路由器的IP地址和硬件地址的映射问题，ARP高速缓存用来存放本局域网中各主机和路由器中的IP地址到MAC地址的映射表*  
工作原理  
1. 当主机发送数据时，首先检查高速缓存列表中是否有对应IP地址的MAC地址，如果有，直接发送，否则，在本局域网上**广播发送ARP请求分组**，包括源主机的IP地址、MAC地址，以及目的主机的IP地址；
2. 本局域网中所有主机接收到该ARP请求分组，检查其中的目的IP地址是否与自己的一致，若不一致，则忽略该数据包，若相同，则将数据包的源主机IP和MAC地址写于ARP告诉缓存映射表，然后向源主机发送ARP响应分组，在此响应中写入自己的MAC地址
3. 源主机接收到响应后，将目的主机的IP和MAC地址写入ARP缓存
4. 广播发送ARP请求分组，单薄发送ARP响应分组  

**RARP**  
*逆地址解析协议，将MAC地址解析为IP地址的协议，主要用于无盘工作站引导时获取IP地址*  
1. 源端发送一个本地的RARP广播包，包中声明自己的MAC地址，并请求任何收到此请求的RARP服务器分配一个IP地址。
2. 本地网段上的RARP服务器接收到此请求后，检查其RARP列表，查找该MAC地址对应的IP地址，如果存在，就返回一个响应，告知其IP，如果不存在，不做任何响应
3. 源端在接收到响应后，利用得到的IP地址进行通信，如果一直没有接收到RARP服务器的响应，则初始化失败
4. 广播发送RARP请求分组，单播发送RARP响应分组  
