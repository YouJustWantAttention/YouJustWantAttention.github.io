---
layout: default
title: HotSpot中的对象
published: 2019-10-02
tags: [深入理解JVM虚拟机,java]
---

*对象所需内存的大小在类加载完后便可确认*

对象的分配方式：
 - 指针碰撞：堆中内存分配规整，用过的在一边，空闲的在另一半，只需要维护一个指针
 - 空闲列表：与指针碰撞相对应，内存分配不规整

**分配方式由Java堆是否规整决定，而Java堆是否规整，取决于采用的垃圾回收器是否有压缩整理功能**

 - Serial、ParNew等带有压缩整理功能，所以系统采用指针碰撞方式
 - CMS基于Mark-Sweep算法，通常采用指针碰撞

**内存分配的多线程同步问题**

 - CAS失败重试方式
 - 分配动作按照线程划分在不同空间进行，每个线程分配一个**本地线程分配缓冲区（TLAB）**，只有TLAB用完且要分配新的TLAB的时候才需要同步锁定；可以通过-XX:+/-UseTLAB来设定

内存分配完成后，要将内存空间初始化为0，不包括对象头，如果使用TLAB，也可以提前到TLAB分配时进行。**该操作保证对象的实例字段不赋值的时候可以访问到零值**

**在HotSpot中，对象在内存中的布局可以分为三部分：对象头、实例数据、对齐填充**

对象头：

 1. mark word：哈希码、gc分代年龄、锁状态标志位、线程持有的锁、偏向线程id等
 2. 类型指针：指向类元数据，通过该指针确定对象属于哪个类。不是所有虚拟机都保留这个类型指针，也就是说，查找对象的元数据信息不一定要经过对象本身
 3. 如果是数组，还需要一个长度字段

 实例数据：对象的真正有效信息
 对齐填充：并不是必须存在，HotSpot虚拟机的内存管理系统要求对象的大小必须是8字节的整数倍，所以需要填充

**对象的访问定位**
栈中的引用类型如何定位到对象，由虚拟机自己决定，目前主流是**句柄和直接指针**两种方式

 - 如果使用句柄，Java堆中会有一块区域作为句柄池，栈中reference存放的是对象句柄的位置，句柄中包含对象的实例数据和类型数据的各自的具体地址
 - 如果使用直接引用，则必须要考虑如何放置访问类型相关的信息
 - 句柄优势在于有稳定的句柄地址，对象位置移动时，引用不用改变，而直接引用速度快，HotSpot采用直接引用