---
layout: default
title: 数据库相关
published: 2019-10-03
tags: [数据库]
---
**优化数据类型**  
- 更小的通常更好：使用可以正确存储数据的最小数据类型
- 简单就好：简单的数据类型操作更快，比如整型就比字符串快。存日期时用date、time、datetime而不是字符串；存IP地址用整型
- 尽量避免null：此条性能提升一般不大。InnoDB使用单独的位存储null值，所以对于稀疏数据有很好的空间利用率，但是这一点不适用于MyISAM  

**整数类型**  
|  |tinyint|smallint|mediumint|int|bigint|  
|--|--|--|--|--|--|  
|位数|8|16|24|32|64|  

**字符串类型**  
字符串定义的是字符数，不是字节数；
1. varchar：   
- 仅使用必需的空间，用额外1-2个字节记录长度。
- 如果更新时行长度增长，而页内没有足够的空间，MyISAM会将行拆成不同的片段，InnoDB需要分裂页，不同引擎处理方式不同。
- 合适的情况：字符串列最大长度比平均长度大很多；列更新很少；使用了UTF8这类复杂字符集，每个字符都使用不同的字节数进行存储；  
2. char
- 定长
- 存储时会去除末尾空格，首部的空格不会去除
- 适用情况：短字符串或者长度差不多；密码的MD5值，因为这个是定长；经常变更的数据，因为不容易产生碎片；

**BLOB和TEXT**
- 都是二进制，但是BLOB是没有排序规则或字符集的，而TEXT是有排序规则和字符集的
- 与其他数据类型的排序不同，这俩的排序只取最前的max_sort_length字节
- MySQL不能将其全部长度作为索引  

**数据库范式**  
1. 所有的域都应该是原子性的  
2. 在1NF范式的基础上，消除非主属性对于码的<u>部分函数依赖</u>（属性依赖主键）
3. 在2NF基础上消除非主属性对于码的传递函数依赖（属性只依赖主键）
4. 巴斯-科德范式（BCNF），在3NF基础上消除对主码子集的依赖  

**B-TREE**
1. 有效
    - 全值匹配
    - 匹配最左前缀
    - 匹配列前缀
    - 匹配范围值
    - 精确匹配某一列并范围匹配另一列
    - 只访问索引的查询
2. 限制
    - 如果不是按照最左列开始查询，则无法使用（优化器会优化的）
    - 不能跳过索引中的列
    - 如果查询中有某个列的范围查询，则右侧的都无法使用索引  

**哈希索引**
- 只有精确匹配索引所有的列的查询才有效
- 只包含哈希值和行指针，所以不能使用索引中的值来避免读行（影响不大）
- 并不是按照索引值顺序进行排序，所以也就无法用于排序
- 不支持部分索引列匹配查找
- 只支持等值比较（=、IN()、<=>），也不支持任何范围查询
- 访问数据非常快，除非哈希冲突很多（拉链法）
- 哈希冲突很多的时候，维护索引代价就很大
- InnoDB有自适应哈希索引  

**全文索引**  


**聚簇索引**  
- 聚簇指的是数据行和键值连在一起
- 一个表只能有一个聚簇索引
- InnoDB通过主键构建聚簇索引，如果没有定义主键则会自动找唯一非空索引，如果找不到就隐式构建主键
- 优势  
    1. 相关数据可以保存在一起，读取的时候减少访存次数
    2. 数据访问快，因为索引和数据在一起
    3. 使用覆盖索引扫描的查询可以直接使用页节点中的主键值
- 缺点  
    1. 如果数据都在内存中，则没有优势
    2. 插入速度严重依赖插入顺序
    3. 更新聚簇索引列的代价很高，因为会强制InnoDB将每个更新的行移动到新的位置
    4. 插入新行或者需要行移动的时候可能会有页分裂，导致占用更多的磁盘空间
    5. 可能导致全表扫描变慢
    6. 二级索引可能比想象的大，因为要包含主键列
    7. 二级索引的访问需要两次查询  

**覆盖索引**
*如果索引包含（覆盖）所有要查询的字段的值，则称为覆盖索引*
- 并非所有的索引都可以成为覆盖索引，覆盖索引必须要存储索引列的值，哈希索引、空间索引、全文索引都不能存储列值  

**索引与order by**
- 只有当索引的列顺序和order by子句的顺序完全一致，且所有列的排序放向（正序或逆序）一致时，才可以走索引
- 如果前边的列指定一个定值，则可以跳过，继续order by，如果前边的列是范围查询，那就不行了  
